#include "Constants.cginc"
#include "Perlin.cginc"
#include "NoiseParams.cginc"

#define SPHERICAL

#pragma kernel RenderTextures
#pragma kernel RenderNormals

// two textures side by side:
// 
// y/r
// ^ ┌───┬───┐
// | │ 0 │ 1 │
// | └───┴───┘
//   --> x/ang
RWTexture2D<float4> bTerrain_VertexTexturePair;
RWTexture2D<float4> bTerrain_NormalTexturePair;

//parameters
float3 uTerrain_targetPos;
uint uTerrain_littleSectorCount;
uint uTerrain_radius;
float uTerrain_coveragePercent;
bool uTerrain_writeTargetSelect;//specifies, which part of bTerrain_VertexTexturePair to write to


float GetRadius(float uv_y)
{
	float angle = uv_y * (PI / 2.0 / (float)uTerrain_radius * uTerrain_coveragePercent);
	float maxAmplitude_half = 2 * uTerrainNoise_amplitudeMul;
	return (uTerrain_targetPos.y + maxAmplitude_half) * tan(angle);
}

//get vertex position. y will be 0
float3 GetVertexPos(uint2 uv, out float angle, out float radius)
{
	angle = uv.x * (TAU / (float)uTerrain_littleSectorCount);
	radius = GetRadius(uv.y);

	return float3(
			radius * cos(angle) + uTerrain_targetPos.x,
			0,
			radius * sin(angle) + uTerrain_targetPos.z
		);
}
float3 GetVertexPos(uint2 uv) {
	float ang, r;
	return GetVertexPos(uv, ang, r);
}

float GetHeight(float2 pos, float maxFreq)
{
	float octaveCount = log2(maxFreq / uTerrainNoise_minorFreq) + 1;
	octaveCount = max(1.001, octaveCount);

	return LayeredPerlin2D(pos, octaveCount, uTerrainNoise_minorFreq) * uTerrainNoise_amplitudeMul;
}

[numthreads(8,8,1)]
void RenderTextures (uint3 uv : SV_DispatchThreadID)
{
	//discard if out of bounds
	if (uv.x > uTerrain_littleSectorCount || uv.y > uTerrain_radius)
		return;

	//get vertex position (y = 0 for now)
	float vAngle, vRadius;
	float3 vertexPos = GetVertexPos(uv.xy, vAngle, vRadius);

	//calculate vertexPos.y
	float dr = GetRadius(uv.y + 1) - vRadius;//square width at vertexPos
	float maxFrequency = 1 / dr / uTerrainNoise_verticesPerWave;
	vertexPos.y = GetHeight(vertexPos.xz, maxFrequency);
	
	//uv += uint3(uTerrain_writeTargetSelect * uTerrain_littleSectorCount, 0, 0);//select target
	bTerrain_VertexTexturePair[uv.xy] = float4(vertexPos, 0);
}


float3 GetNormal(uint2 uv)
{
	//calculate sample points for numerical partial derivatives
	float3 p00, p10, p01;
	if (uv.y != 0)//if not centre point
	{
		//prevent out of bounds errors
		uv -= uint2(uv.x >= uTerrain_littleSectorCount, 0);
		uv -= uint2(0, uv.y >= uTerrain_radius);

		p00 = (float3)bTerrain_VertexTexturePair[uv];
		p10 = (float3)bTerrain_VertexTexturePair[uv + uint2(1, 0)];
		p01 = (float3)bTerrain_VertexTexturePair[uv + uint2(0, 1)];

	}
	else//if centre point
	{
		p00 = (float3)bTerrain_VertexTexturePair[uint2(0, 0)];
		p10 = (float3)bTerrain_VertexTexturePair[uint2(uTerrain_littleSectorCount / 4, 1)];
		p01 = (float3)bTerrain_VertexTexturePair[uint2(0, 1)];
	}
	
	//numerical partial derivatives
	float3 ddx = p00 - p10;
	float3 ddy = p00 - p01;

	return normalize(cross(ddx, ddy));
}

[numthreads(8, 8, 1)]
void RenderNormals(uint3 uv : SV_DispatchThreadID)
{
	bTerrain_NormalTexturePair[uv.xy] = float4(GetNormal(uv.xy), 0);
}